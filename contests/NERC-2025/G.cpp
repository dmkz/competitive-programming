// метод Гаусса, бинарный поиск, жадные алгоритмы
#include <bits/stdc++.h>
#define all(x) (x).begin(),(x).end()
#define isz(x) (int)(x).size()
#define int ll
using ll = long long;
using vi = std::vector<int>;
using vl = std::vector<ll>;
void remin(auto &x, const auto &y) { if (y < x) x = y; }
void remax(auto &x, const auto &y) { if (x < y) x = y; }
void solve() {
    // Составим систему линейных уравнений и найдём для каждого вектора вида
    // (0, ..., 1, 1, ..., 0) сколько раз мы должны его использовать
    // Например, для теста из условия n = 6, a = {5, 8, 3, 10, 14, 4}:
    // 1 0 0 0 0 1 | 5
    // 1 1 0 0 0 0 | 8
    // 0 1 1 0 0 0 | 3
    // 0 0 1 1 0 0 | 10
    // 0 0 0 1 1 0 | 14
    // 0 0 0 0 1 1 | 4
    // Решаем эту систему: вычитаем последовательно (i-1)-е уравнение из i-го:
    // 1 0 0 0 0  1 | 5
    // 0 1 0 0 0 -1 | 3
    // 0 0 1 0 0  1 | 0
    // 0 0 0 1 0 -1 | 10
    // 0 0 0 0 1  1 | 4
    // 0 0 0 0 0  0 | 0
    // Для чётного n ранг = n-1, есть свободная переменная, которую мы можем изменять
    // как угодно. Обозначим её за x, тогда решение - линейная функция относительно x:
    // Решение = {5 - x, 3 + x, -x, 10 + x, 4 - x, x}
    // Так как нам нужно как можно меньше раундов сделать, то максимум в векторе-ответе
    // Должен быть как можно меньше. Поэтому находим оптимальный x бинарным поиском.
    // Для нечётного n ранг равен n и мы применяем обратный ход метода Гаусса, находим
    // вектор-ответ однозначно:
    // 1 0  1 | a1
    // 0 1 -1 | a2
    // 0 0  2 | a3 <-- обратный ход Гаусса начиная с последней строки
    // Итак, теперь мы получили вектор-ответ. Мы знаем сколько "включений" пар нам надо
    // Мы должны распределить их по раундам оптимальным образом. Мы не можем в один
    // раунд включить все n векторов, потому что такого не бывает: чтобы для каждой
    // пары соседей на окружности у нас было слева "меньше" справа.
    // Поэтому мы можем максимум (n-1) векторов использовать одновременно. Возможны два
    // случая:
    // 1) либо мы каждый раз можем уменьшать сумму компонент вектора на (n-1)
    // 2) либо мы упрёмся в максимальный элемент
    // Поэтому ответ на задачу равен: max(ceil(sum / (n-1)), maxElement).
    int n; std::cin >> n;
    vl a(n);
    for (int i = 0; i < n; i++)
        std::cin >> a[i];
    // прямой ход метода Гаусса:
    for (int i = 1; i < n; i++)
        a[i] -= a[i-1];
    if (n % 2 == 0 && n > 2) {
        // если n - чётное, то последний элемент может быть каким угодно
        // бинарным поиском находим такой, который минимизирует максимальный ответ:
        // можно ли сделать <= mid?
        const ll inf = (ll)1e18L;
        auto getSegment = [&](ll mid){
            // сам последний элемент на отрезке [0, mid]:
            ll totalL = 0, totalR = mid;
            // чётные строки:
            for (int i = 0; i + 1 < n; i += 2) {
                // a[i] - x <= mid
                // a[i] - x >= 0
                ll L = a[i] - mid;
                ll R = a[i];
                remax(totalL, L);
                remin(totalR, R);
            }
            // нечётные строки:
            for (int i = 1; i + 1 < n; i += 2) {
                // a[i] + x <= mid
                // a[i] + x >= 0
                ll R = mid - a[i];
                ll L = -a[i];
                remax(totalL, L);
                remin(totalR, R);
            }
            return std::make_pair(totalL, totalR);
        };
        ll low = -1, high = inf;
        while (high - low > 1) {
            ll mid = (low + high) / 2;
            // можно ли сделать ответ <= mid?
            auto [totalL, totalR] = getSegment(mid);
            if (totalL <= totalR) high = mid; // да
            else low = mid; // нет
        }
        // восстанавливаем ответ:
        ll optimalSolution = getSegment(high).first;
        for (int i = 0; i + 1 < n; i++) {
            if (i % 2 == 0)
                a[i] -= optimalSolution;
            else
                a[i] += optimalSolution;
        }
        a.back() = optimalSolution;
    } else {
        // n - нечётное, ответ определяется однозначно
        assert(a.back() % 2 == 0);
        a.back() /= 2;
        // обратный ход метода Гаусса:
        for (int i = 0; i + 1 < n; i++)
            if (i % 2 == 0)
                a[i] -= a.back();
            else
                a[i] += a.back();
    }
    // теперь отсортируем вектор-ответ:
    std::sort(all(a));
    // за один раунд мы не можем взять сразу все векторы, потому что
    // у нас окружность: не можем сразу все неравенства типа "меньше" получить
    if (a.front() == 0) {
        // но если есть ноль, то можем:
        std::cout << *std::max_element(all(a)) << std::endl;
    } else {
        // иначе каждый раз мы будем выбирать все элементы, кроме минимума
        // сумма уменьшается на (n-1), пока не достигнем первого нуля
        // потом ответ это максимум из оставшихся
        ll answ1 = (ll)std::ceil(std::accumulate(all(a), 0LL) / (n-1.0L));
        ll answ2 = *std::max_element(all(a));
        std::cout << std::max(answ1, answ2) << std::endl;
    }
}
main() {
    std::ios::sync_with_stdio(false);
    std::cin.tie(0);
    int tt; std::cin >> tt;
    while (tt --> 0) solve();
}
